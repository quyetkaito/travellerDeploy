{"ast":null,"code":"import \"core-js/modules/es.array.includes.js\";\nimport { rectToClientRect, computePosition as computePosition$1 } from '@floating-ui/core';\nexport { arrow, autoPlacement, detectOverflow, flip, hide, inline, limitShift, offset, shift, size } from '@floating-ui/core';\n\nfunction isWindow(value) {\n  return (value == null ? void 0 : value.toString()) === '[object Window]';\n}\n\nfunction getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n\n  if (!isWindow(node)) {\n    const ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n\n  return node;\n}\n\nfunction getComputedStyle$1(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n\nfunction getNodeName(node) {\n  return isWindow(node) ? '' : node ? (node.nodeName || '').toLowerCase() : '';\n}\n\nfunction isHTMLElement(value) {\n  return value instanceof getWindow(value).HTMLElement;\n}\n\nfunction isElement(value) {\n  return value instanceof getWindow(value).Element;\n}\n\nfunction isNode(value) {\n  return value instanceof getWindow(value).Node;\n}\n\nfunction isShadowRoot(node) {\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\n\nfunction isScrollParent(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  const {\n    overflow,\n    overflowX,\n    overflowY\n  } = getComputedStyle$1(element);\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}\n\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\n\nfunction isContainingBlock(element) {\n  // TODO: Try and use feature detection here instead\n  const isFirefox = navigator.userAgent.toLowerCase().includes('firefox');\n  const css = getComputedStyle$1(element); // This is non-exhaustive but covers the most common CSS properties that\n  // create a containing block.\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n  return css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].includes(css.willChange) || isFirefox && css.willChange === 'filter' || isFirefox && (css.filter ? css.filter !== 'none' : false);\n}\n\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\n\nfunction getBoundingClientRect(element, includeScale) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n\n  const clientRect = element.getBoundingClientRect();\n  let scaleX = 1;\n  let scaleY = 1;\n\n  if (includeScale && isHTMLElement(element)) {\n    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n  }\n\n  return {\n    width: clientRect.width / scaleX,\n    height: clientRect.height / scaleY,\n    top: clientRect.top / scaleY,\n    right: clientRect.right / scaleX,\n    bottom: clientRect.bottom / scaleY,\n    left: clientRect.left / scaleX,\n    x: clientRect.left / scaleX,\n    y: clientRect.top / scaleY\n  };\n}\n\nfunction getDocumentElement(node) {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\n\nfunction getNodeScroll(element) {\n  if (isWindow(element)) {\n    return {\n      scrollLeft: element.pageXOffset,\n      scrollTop: element.pageYOffset\n    };\n  }\n\n  return {\n    scrollLeft: element.scrollLeft,\n    scrollTop: element.scrollTop\n  };\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\nfunction isScaled(element) {\n  const rect = getBoundingClientRect(element);\n  return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const rect = getBoundingClientRect(element, isOffsetParentAnElement && isScaled(offsetParent));\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isScrollParent(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n\n  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // @ts-ignore\n    node.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    node.parentNode || ( // DOM Element detected\n    isShadowRoot(node) ? node.host : null) || // ShadowRoot detected\n    getDocumentElement(node) // fallback\n\n  );\n}\n\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n\n  return element.offsetParent;\n}\n\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n\n  while (isHTMLElement(currentNode) && !['html', 'body'].includes(getNodeName(currentNode))) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = currentNode.parentNode;\n    }\n  }\n\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\n\n\nfunction getOffsetParent(element) {\n  const window = getWindow(element);\n  let offsetParent = getTrueOffsetParent(element);\n\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nfunction getDimensions(element) {\n  return {\n    width: element.offsetWidth,\n    height: element.offsetHeight\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isScrollParent(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } // This doesn't appear to be need to be negated.\n    // else if (documentElement) {\n    //   offsets.x = getWindowScrollBarX(documentElement);\n    // }\n\n  }\n\n  return { ...rect,\n    x: rect.x - scroll.scrollLeft + offsets.x,\n    y: rect.y - scroll.scrollTop + offsets.y\n  };\n}\n\nfunction getViewportRect(element) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)\n    // In Chrome, it returns a value very close to 0 (+/-) but contains rounding\n    // errors due to floating point numbers, so we need to check precision.\n    // Safari returns a number <= 0, usually < -1 when pinch-zoomed\n\n    if (Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) < 0.01) {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n} // of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\n\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n\n  if (getComputedStyle$1(body || html).direction === 'rtl') {\n    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getScrollParent(node) {\n  if (['html', 'body', '#document'].includes(getNodeName(node))) {\n    // @ts-ignore assume body is always available\n    return node.ownerDocument.body;\n  }\n\n  if (isHTMLElement(node) && isScrollParent(node)) {\n    return node;\n  }\n\n  return getScrollParent(getParentNode(node));\n}\n\nfunction getScrollParents(node, list) {\n  var _node$ownerDocument;\n\n  if (list === void 0) {\n    list = [];\n  }\n\n  const scrollParent = getScrollParent(node);\n  const isBody = scrollParent === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n  const win = getWindow(scrollParent);\n  const target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\n  const updatedList = list.concat(target);\n  return isBody ? updatedList : // @ts-ignore: isBody tells us target will be an HTMLElement here\n  updatedList.concat(getScrollParents(getParentNode(target)));\n}\n\nfunction contains(parent, child) {\n  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode(); // First, attempt with faster native method\n\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n\n    do {\n      // use `===` replace node.isSameNode()\n      if (next && parent === next) {\n        return true;\n      } // @ts-ignore: need a better way to handle this...\n\n\n      next = next.parentNode || next.host;\n    } while (next);\n  }\n\n  return false;\n}\n\nfunction getInnerBoundingClientRect(element) {\n  const clientRect = getBoundingClientRect(element);\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  return {\n    top,\n    left,\n    x: left,\n    y: top,\n    right: left + element.clientWidth,\n    bottom: top + element.clientHeight,\n    width: element.clientWidth,\n    height: element.clientHeight\n  };\n}\n\nfunction getClientRectFromClippingParent(element, clippingParent) {\n  if (clippingParent === 'viewport') {\n    return rectToClientRect(getViewportRect(element));\n  }\n\n  if (isElement(clippingParent)) {\n    return getInnerBoundingClientRect(clippingParent);\n  }\n\n  return rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping parent\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n\nfunction getClippingParents(element) {\n  const clippingParents = getScrollParents(getParentNode(element));\n  const canEscapeClipping = ['absolute', 'fixed'].includes(getComputedStyle$1(element).position);\n  const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n\n  if (!isElement(clipperElement)) {\n    return [];\n  } // @ts-ignore isElement check ensures we return Array<Element>\n\n\n  return clippingParents.filter(clippingParent => isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body');\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping parents\n\n\nfunction getClippingClientRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary\n  } = _ref;\n  const mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n  const clippingParents = [...mainClippingParents, rootBoundary];\n  const firstClippingParent = clippingParents[0];\n  const clippingRect = clippingParents.reduce((accRect, clippingParent) => {\n    const rect = getClientRectFromClippingParent(element, clippingParent);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingParent(element, firstClippingParent));\n  clippingRect.width = clippingRect.right - clippingRect.left;\n  clippingRect.height = clippingRect.bottom - clippingRect.top;\n  clippingRect.x = clippingRect.left;\n  clippingRect.y = clippingRect.top;\n  return clippingRect;\n}\n\nconst platform = {\n  getElementRects: _ref => {\n    let {\n      reference,\n      floating,\n      strategy\n    } = _ref;\n    return {\n      reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),\n      floating: { ...getDimensions(floating),\n        x: 0,\n        y: 0\n      }\n    };\n  },\n  convertOffsetParentRelativeRectToViewportRelativeRect: args => convertOffsetParentRelativeRectToViewportRelativeRect(args),\n  getOffsetParent: _ref2 => {\n    let {\n      element\n    } = _ref2;\n    return getOffsetParent(element);\n  },\n  isElement: value => isElement(value),\n  getDocumentElement: _ref3 => {\n    let {\n      element\n    } = _ref3;\n    return getDocumentElement(element);\n  },\n  getClippingClientRect: args => getClippingClientRect(args),\n  getDimensions: _ref4 => {\n    let {\n      element\n    } = _ref4;\n    return getDimensions(element);\n  },\n  getClientRects: _ref5 => {\n    let {\n      element\n    } = _ref5;\n    return element.getClientRects();\n  }\n};\n\nconst computePosition = (reference, floating, options) => computePosition$1(reference, floating, {\n  platform,\n  ...options\n});\n\nexport { computePosition, getScrollParents };","map":{"version":3,"names":["rectToClientRect","computePosition","computePosition$1","arrow","autoPlacement","detectOverflow","flip","hide","inline","limitShift","offset","shift","size","isWindow","value","toString","getWindow","node","window","ownerDocument","defaultView","getComputedStyle$1","element","getComputedStyle","getNodeName","nodeName","toLowerCase","isHTMLElement","HTMLElement","isElement","Element","isNode","Node","isShadowRoot","OwnElement","ShadowRoot","isScrollParent","overflow","overflowX","overflowY","test","isTableElement","includes","isContainingBlock","isFirefox","navigator","userAgent","css","transform","perspective","contain","willChange","filter","min","Math","max","round","getBoundingClientRect","includeScale","clientRect","scaleX","scaleY","offsetWidth","width","offsetHeight","height","top","right","bottom","left","x","y","getDocumentElement","document","documentElement","getNodeScroll","scrollLeft","pageXOffset","scrollTop","pageYOffset","getWindowScrollBarX","isScaled","rect","getRectRelativeToOffsetParent","offsetParent","strategy","isOffsetParentAnElement","scroll","offsets","offsetRect","clientLeft","clientTop","getParentNode","assignedSlot","parentNode","host","getTrueOffsetParent","position","getContainingBlock","currentNode","getOffsetParent","getDimensions","convertOffsetParentRelativeRectToViewportRelativeRect","_ref","getViewportRect","win","html","visualViewport","clientWidth","clientHeight","abs","innerWidth","scale","offsetLeft","offsetTop","getDocumentRect","_element$ownerDocumen","body","scrollWidth","scrollHeight","direction","getScrollParent","getScrollParents","list","_node$ownerDocument","scrollParent","isBody","target","concat","updatedList","contains","parent","child","rootNode","getRootNode","next","getInnerBoundingClientRect","getClientRectFromClippingParent","clippingParent","getClippingParents","clippingParents","canEscapeClipping","clipperElement","getClippingClientRect","boundary","rootBoundary","mainClippingParents","firstClippingParent","clippingRect","reduce","accRect","platform","getElementRects","reference","floating","args","_ref2","_ref3","_ref4","getClientRects","_ref5","options"],"sources":["D:/Traveller/Traveller-Frontend/traveller-ui/node_modules/@floating-ui/dom/dist/floating-ui.dom.esm.js"],"sourcesContent":["import { rectToClientRect, computePosition as computePosition$1 } from '@floating-ui/core';\nexport { arrow, autoPlacement, detectOverflow, flip, hide, inline, limitShift, offset, shift, size } from '@floating-ui/core';\n\nfunction isWindow(value) {\n  return (value == null ? void 0 : value.toString()) === '[object Window]';\n}\nfunction getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n\n  if (!isWindow(node)) {\n    const ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n\n  return node;\n}\n\nfunction getComputedStyle$1(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n\nfunction getNodeName(node) {\n  return isWindow(node) ? '' : node ? (node.nodeName || '').toLowerCase() : '';\n}\n\nfunction isHTMLElement(value) {\n  return value instanceof getWindow(value).HTMLElement;\n}\nfunction isElement(value) {\n  return value instanceof getWindow(value).Element;\n}\nfunction isNode(value) {\n  return value instanceof getWindow(value).Node;\n}\nfunction isShadowRoot(node) {\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\nfunction isScrollParent(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  const {\n    overflow,\n    overflowX,\n    overflowY\n  } = getComputedStyle$1(element);\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  // TODO: Try and use feature detection here instead\n  const isFirefox = navigator.userAgent.toLowerCase().includes('firefox');\n  const css = getComputedStyle$1(element); // This is non-exhaustive but covers the most common CSS properties that\n  // create a containing block.\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n  return css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].includes(css.willChange) || isFirefox && css.willChange === 'filter' || isFirefox && (css.filter ? css.filter !== 'none' : false);\n}\n\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\n\nfunction getBoundingClientRect(element, includeScale) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n\n  const clientRect = element.getBoundingClientRect();\n  let scaleX = 1;\n  let scaleY = 1;\n\n  if (includeScale && isHTMLElement(element)) {\n    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n  }\n\n  return {\n    width: clientRect.width / scaleX,\n    height: clientRect.height / scaleY,\n    top: clientRect.top / scaleY,\n    right: clientRect.right / scaleX,\n    bottom: clientRect.bottom / scaleY,\n    left: clientRect.left / scaleX,\n    x: clientRect.left / scaleX,\n    y: clientRect.top / scaleY\n  };\n}\n\nfunction getDocumentElement(node) {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\n\nfunction getNodeScroll(element) {\n  if (isWindow(element)) {\n    return {\n      scrollLeft: element.pageXOffset,\n      scrollTop: element.pageYOffset\n    };\n  }\n\n  return {\n    scrollLeft: element.scrollLeft,\n    scrollTop: element.scrollTop\n  };\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\nfunction isScaled(element) {\n  const rect = getBoundingClientRect(element);\n  return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const rect = getBoundingClientRect(element, isOffsetParentAnElement && isScaled(offsetParent));\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isScrollParent(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n\n  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // @ts-ignore\n    node.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    node.parentNode || ( // DOM Element detected\n    isShadowRoot(node) ? node.host : null) || // ShadowRoot detected\n    getDocumentElement(node) // fallback\n\n  );\n}\n\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n\n  return element.offsetParent;\n}\n\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n\n  while (isHTMLElement(currentNode) && !['html', 'body'].includes(getNodeName(currentNode))) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = currentNode.parentNode;\n    }\n  }\n\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\n\n\nfunction getOffsetParent(element) {\n  const window = getWindow(element);\n  let offsetParent = getTrueOffsetParent(element);\n\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nfunction getDimensions(element) {\n  return {\n    width: element.offsetWidth,\n    height: element.offsetHeight\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isScrollParent(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } // This doesn't appear to be need to be negated.\n    // else if (documentElement) {\n    //   offsets.x = getWindowScrollBarX(documentElement);\n    // }\n\n  }\n\n  return { ...rect,\n    x: rect.x - scroll.scrollLeft + offsets.x,\n    y: rect.y - scroll.scrollTop + offsets.y\n  };\n}\n\nfunction getViewportRect(element) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height; // Uses Layout Viewport (like Chrome; Safari does not currently)\n    // In Chrome, it returns a value very close to 0 (+/-) but contains rounding\n    // errors due to floating point numbers, so we need to check precision.\n    // Safari returns a number <= 0, usually < -1 when pinch-zoomed\n\n    if (Math.abs(win.innerWidth / visualViewport.scale - visualViewport.width) < 0.01) {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n\n  if (getComputedStyle$1(body || html).direction === 'rtl') {\n    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getScrollParent(node) {\n  if (['html', 'body', '#document'].includes(getNodeName(node))) {\n    // @ts-ignore assume body is always available\n    return node.ownerDocument.body;\n  }\n\n  if (isHTMLElement(node) && isScrollParent(node)) {\n    return node;\n  }\n\n  return getScrollParent(getParentNode(node));\n}\n\nfunction getScrollParents(node, list) {\n  var _node$ownerDocument;\n\n  if (list === void 0) {\n    list = [];\n  }\n\n  const scrollParent = getScrollParent(node);\n  const isBody = scrollParent === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n  const win = getWindow(scrollParent);\n  const target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\n  const updatedList = list.concat(target);\n  return isBody ? updatedList : // @ts-ignore: isBody tells us target will be an HTMLElement here\n  updatedList.concat(getScrollParents(getParentNode(target)));\n}\n\nfunction contains(parent, child) {\n  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode(); // First, attempt with faster native method\n\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && isShadowRoot(rootNode)) {\n    let next = child;\n\n    do {\n      // use `===` replace node.isSameNode()\n      if (next && parent === next) {\n        return true;\n      } // @ts-ignore: need a better way to handle this...\n\n\n      next = next.parentNode || next.host;\n    } while (next);\n  }\n\n  return false;\n}\n\nfunction getInnerBoundingClientRect(element) {\n  const clientRect = getBoundingClientRect(element);\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  return {\n    top,\n    left,\n    x: left,\n    y: top,\n    right: left + element.clientWidth,\n    bottom: top + element.clientHeight,\n    width: element.clientWidth,\n    height: element.clientHeight\n  };\n}\n\nfunction getClientRectFromClippingParent(element, clippingParent) {\n  if (clippingParent === 'viewport') {\n    return rectToClientRect(getViewportRect(element));\n  }\n\n  if (isElement(clippingParent)) {\n    return getInnerBoundingClientRect(clippingParent);\n  }\n\n  return rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping parent\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n\nfunction getClippingParents(element) {\n  const clippingParents = getScrollParents(getParentNode(element));\n  const canEscapeClipping = ['absolute', 'fixed'].includes(getComputedStyle$1(element).position);\n  const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n\n  if (!isElement(clipperElement)) {\n    return [];\n  } // @ts-ignore isElement check ensures we return Array<Element>\n\n\n  return clippingParents.filter(clippingParent => isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body');\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping parents\n\n\nfunction getClippingClientRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary\n  } = _ref;\n  const mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n  const clippingParents = [...mainClippingParents, rootBoundary];\n  const firstClippingParent = clippingParents[0];\n  const clippingRect = clippingParents.reduce((accRect, clippingParent) => {\n    const rect = getClientRectFromClippingParent(element, clippingParent);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingParent(element, firstClippingParent));\n  clippingRect.width = clippingRect.right - clippingRect.left;\n  clippingRect.height = clippingRect.bottom - clippingRect.top;\n  clippingRect.x = clippingRect.left;\n  clippingRect.y = clippingRect.top;\n  return clippingRect;\n}\n\nconst platform = {\n  getElementRects: _ref => {\n    let {\n      reference,\n      floating,\n      strategy\n    } = _ref;\n    return {\n      reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),\n      floating: { ...getDimensions(floating),\n        x: 0,\n        y: 0\n      }\n    };\n  },\n  convertOffsetParentRelativeRectToViewportRelativeRect: args => convertOffsetParentRelativeRectToViewportRelativeRect(args),\n  getOffsetParent: _ref2 => {\n    let {\n      element\n    } = _ref2;\n    return getOffsetParent(element);\n  },\n  isElement: value => isElement(value),\n  getDocumentElement: _ref3 => {\n    let {\n      element\n    } = _ref3;\n    return getDocumentElement(element);\n  },\n  getClippingClientRect: args => getClippingClientRect(args),\n  getDimensions: _ref4 => {\n    let {\n      element\n    } = _ref4;\n    return getDimensions(element);\n  },\n  getClientRects: _ref5 => {\n    let {\n      element\n    } = _ref5;\n    return element.getClientRects();\n  }\n};\n\nconst computePosition = (reference, floating, options) => computePosition$1(reference, floating, {\n  platform,\n  ...options\n});\n\nexport { computePosition, getScrollParents };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}